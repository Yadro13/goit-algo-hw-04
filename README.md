
# Аналіз алгоритмів сортування: Merge Sort, Insertion Sort, Timsort

## Вступ

У цьому дослідженні було порівняно три алгоритми сортування:
- **Merge Sort** (сортування злиттям)
- **Insertion Sort** (сортування вставками)
- **Timsort** (вбудований алгоритм Python, використовується у `sorted()` і `.sort()`)

Метою було емпірично перевірити теоретичну складність цих алгоритмів і продемонструвати перевагу Timsort — гібридного алгоритму, що поєднує сортування злиттям і вставками.

## Теоретичні оцінки складності

| Алгоритм        | Найгірший випадок | Середній випадок | Найкращий випадок |
|------------------|-------------------|-------------------|--------------------|
| Insertion Sort   | O(n²)             | O(n²)             | O(n)               |
| Merge Sort       | O(n log n)        | O(n log n)        | O(n log n)         |
| Timsort (Python) | O(n log n)        | O(n log n)        | O(n)               |

## Емпіричне тестування

Тестування проводилось на випадкових масивах розміром від 100 до 100000 елементів. Для вимірювання часу виконання використовувався модуль `timeit`. 

     Size  Merge Sort  Insertion Sort   Timsort
0     100    0.000137        0.000173  0.000008
1     500    0.000876        0.004695  0.000047
2    1000    0.001880        0.023579  0.000103
3    2000    0.004124        0.092101  0.000209
4    5000    0.012014        0.598551  0.000603
5   10000    0.026753        2.405574  0.001273
6   20000    0.058144       10.195672  0.002783
7   50000    0.157810       83.400924  0.009947
8  100000    0.513817      324.622418  0.019085

### Порівняння результатів

- **Merge Sort** показав очікувану логарифмічну залежність від розміру вхідних даних.
- **Insertion Sort** був прийнятним лише на малих наборах (до 500), але на більших — значно сповільнювався.
- **Timsort** стабільно був найшвидшим, завдяки ефективному гібридному підходу.

Додатково див. Figure_1.png (від 100 до 100000) та Figure_1.png (від 100 до 5000)

## Висновки

- Поєднання сортування злиттям і вставками дозволяє Timsort працювати ефективно як на малих, так і на великих даних.
- Використання вбудованих функцій Python (`sorted`, `.sort()`) — це не лише зручність, а й ефективність.
- У більшості реальних задач **немає сенсу реалізовувати сортування вручну**, оскільки вбудований алгоритм Timsort вже оптимізований і протестований.

## Рекомендація

Для будь-яких задач сортування в Python рекомендується використовувати `sorted()` або `.sort()`, оскільки вони використовують Timsort, який є одним із найефективніших загального призначення.
# goit-algo-hw-04
