
# Bonus: Чи можна обігнати Timsort?

## Вступ

Ми провели експеримент, щоб спробувати **обігнати Timsort** (вбудований алгоритм Python, який використовується у `sorted()`) за допомогою теоретично швидшого **Counting Sort**, реалізованого з оптимізацією через `Numba`.

## Теоретичні передумови

Counting Sort має складність **O(n + k)** і при обмеженому діапазоні значень має бути швидшим за Timsort, який працює у **O(n log n)**.

## Умови експерименту

- Дані: масиви з цілих чисел у діапазоні [0, 1000]
- Розміри: від 100 до 100000 елементів
- Алгоритми:
  - `sorted()` (Timsort)
  - `counting_sort_numba()` — Counting Sort з компіляцією через `@numba.njit`

## Результати

На практиці:

! Спроба 1 Counting Sort без Numba

Додатково див. Figure_3.png

! Спроба 2 Counting Sort через Numba

| Size	| Counting Sort (Numba)	| Timsort	
|------	|-----------------------|--------	
| 100	| 0.000196		| 0.000213	
| 500	| 0.000931		| 0.000084	
| 1000	| 0.001839		| 0.000174	
| 2000	| 0.003845		| 0.000486	
| 5000	| 0.013890		| 0.001123	
| 10000	| 0.019769		| 0.002509	
| 20000	| 0.040885		| 0.007061	
| 50000	| 0.141285		| 0.018254	
| 100000| 0.187278		| 0.027909	

Додатково див. Figure_4.png

- **Timsort був швидшим практично у всіх випадках** — навіть при оптимізації Counting Sort через Numba, окрім випадку замалого розміру набору.
- Навіть на великих масивах різниця зменшується, але перевага Timsort залишається.
- Це доводить, що **реалізація важливіша за теоретичну складність**.

## Причини, чому Counting Sort не обігнав Timsort

| Причина | Пояснення |
|--------|-----------|
| Timsort = C-реалізація | Працює набагато швидше, ніж Python-код |
| Алокація масивів у Counting Sort | Викликає затримки, навіть з Numba |
| Діапазон значень = 1000 | Велика count-таблиця потребує часу |
| Numba не оптимізує алокації | Вручну створені списки повільні |

## Висновок

> **Timsort у Python — не лише найкращий з точки зору складності, а й найшвидший на практиці.**

Спроби обігнати його вимагають:
- Або набагато вужчого діапазону значень,
- Або реалізації сортування в C, Rust, Cython, або з NumPy-оптимізацією,
- Або спеціальних сценаріїв (наприклад, сортування майже відсортованих масивів).

## Рекомендація

Залишайтесь із `sorted()` — доки точно не впевнені, що виграєте за часом.
